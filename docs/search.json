[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Unjournal evaluations: data and analysis",
    "section": "",
    "text": "The Unjournal coordinates the public evaluation of hosted papers and dynamically-presented research projects. We are working independently of traditional academic journals to build an open platform and a sustainable system for feedback, ratings, and assessment. Our initial focus is quantitative work that informs global priorities, especially in economics, policy, and other social sciences. We will encourage better research by making it easier for researchers to get feedback and credible ratings on their work. Our aim: to make rigorous research more impactful, and impactful research more rigorous.\nOur main web site, unjournal.org, explains and presents our vision, procedures, and our progress. The ‘output’ evaluations and author (including feedback and discussion) can be found on our PubPub page, and are indexed in scholarly archives.\nThe present site presents data and analysis on The Unjournal’s pipeline and evaluation output\nIn large part:\n\nKeeping track of what we are covering, when and how\nPresenting the quantitative evaluation content in useful ways\nBenchmarking, checking, and aggregating the expert judgment of our evaluators (as reflected in their ratings and predictions)\n\n\nWe may expand this analysis further in the future, e.g., to include\n\nFurther analysis of the relevant research contexts (e.g., ‘how many papers are coming out by field’)\nConnections to replications and prediction initiatives\nComparing and benchmarking our evaluations against ‘traditional publication outcomes’ for this work (such as journal tiers and citations)\n\n\nThis resource aims to be:\n\nDynamic: Regularly updated to reflect our progress\nTransparent and replicable: sharing data and code to permit checking and ‘forked’ analyses\nInteractive: presenting a dashboard-style interface, allowing readers to choose their analyses of interest\n\n\n10 Aug 2023: David Reinstein and Julia Bottesini have done most of the analysis here.\n\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\nCodeoptions(knitr.duplicate.label = \"allow\")"
  },
  {
    "objectID": "chapters/evaluation_data_input.html",
    "href": "chapters/evaluation_data_input.html",
    "title": "\n1  Evaluation data: input/features\n",
    "section": "",
    "text": "Note on data input (10-Aug-23)\n\n\n\n\n\nBelow, the evaluation data is input from an Airtable, which itself was largely hand-input from evaluators’ reports. As PubPub builds (target: end of Sept. 2023), this will allow us to include the ratings and predictions as structured data objects. We then plan to access and input this data directly from the PubPub (API?) into the present analysis. This will improve automation and limit the potential for data entry errors.\n\n\n\n\ninput from airtablebase_id <- \"appbPYEw9nURln7Qg\"\n\n\n# Set your Airtable API key \nSys.setenv(AIRTABLE_API_KEY = Sys.getenv(\"AIRTABLE_API_KEY\"))\n#this should be set in my .Renviron file\n\n# Read data from a specific view\n\nevals <- air_get(base = base_id, \"output_eval\") \n\nall_pub_records <- data.frame()\npub_records <- air_select(base = base_id, table = \"crucial_research\")\n\n# Append the records to the list\nall_pub_records <- bind_rows(all_pub_records, pub_records)\n\n# While the length of the records list is 100 (the maximum), fetch more records\nwhile(nrow(pub_records) == 100) {\n  # Get the ID of the last record in the list\n  offset <- get_offset(pub_records)\n  \n  # Fetch the next 100 records, starting after the last ID\n  pub_records <- air_select(base = base_id, table = \"crucial_research\", offset =  offset)\n  \n  # Append the records to the df\n  all_pub_records <- bind_rows(all_pub_records, pub_records)\n}\n\n# housekeeping\nrm(pub_records)\n\n\n\njust the useful and publish-able data, clean a bit# clean evals names to snakecase\ncolnames(evals) <- snakecase::to_snake_case(colnames(evals))\n\nevals_pub <- evals %>% \n  dplyr::rename(stage_of_process = stage_of_process_todo_from_crucial_research_2) %>% \n  mutate(stage_of_process = unlist(stage_of_process)) %>% \n  dplyr::filter(stage_of_process == \"published\") %>% \n    select(id, \n           crucial_research, \n           paper_abbrev, \n           evaluator_name, \n           category, \n           source_main, \n           author_agreement, \n           overall, \n           lb_overall, \n           ub_overall, \n           conf_index_overall, \n           advancing_knowledge_and_practice, \n           lb_advancing_knowledge_and_practice, \n           ub_advancing_knowledge_and_practice, \n           conf_index_advancing_knowledge_and_practice,\n           methods_justification_reasonableness_validity_robustness,\n           lb_methods_justification_reasonableness_validity_robustness,\n           ub_methods_justification_reasonableness_validity_robustness,\n           conf_index_methods_justification_reasonableness_validity_robustness, \n           logic_communication, lb_logic_communication, ub_logic_communication, \n           conf_index_logic_communication,\n           engaging_with_real_world_impact_quantification_practice_realism_and_relevance,\n           lb_engaging_with_real_world_impact_quantification_practice_realism_and_relevance,\n           ub_engaging_with_real_world_impact_quantification_practice_realism_and_relevance,\n           conf_index_engaging_with_real_world_impact_quantification_practice_realism_and_relevance,\n           relevance_to_global_priorities, \n           lb_relevance_to_global_priorities, \n           ub_relevance_to_global_priorities, \n           conf_index_relevance_to_global_priorities, \n           journal_quality_predict, \n           lb_journal_quality_predict, \n           ub_journal_quality_predict,\n           conf_index_journal_quality_predict, \n           open_collaborative_replicable, \n           conf_index_open_collaborative_replicable, \n           lb_open_collaborative_replicable, \n           ub_open_collaborative_replicable, \n           merits_journal, \n           lb_merits_journal, \n           ub_merits_journal, \n           conf_index_merits_journal)\n\n# shorten names (before you expand into columns)\nnew_names <- c(\n  \"eval_name\" = \"evaluator_name\",\n  \"cat\" = \"category\",\n  \"crucial_rsx\" = \"crucial_research\",\n  \"conf_overall\" = \"conf_index_overall\",\n  \"adv_knowledge\" = \"advancing_knowledge_and_practice\",\n  \"lb_adv_knowledge\" = \"lb_advancing_knowledge_and_practice\",\n  \"ub_adv_knowledge\" = \"ub_advancing_knowledge_and_practice\",\n  \"conf_adv_knowledge\" = \"conf_index_advancing_knowledge_and_practice\",\n  \"methods\" = \"methods_justification_reasonableness_validity_robustness\",\n  \"lb_methods\" = \"lb_methods_justification_reasonableness_validity_robustness\",\n  \"ub_methods\" = \"ub_methods_justification_reasonableness_validity_robustness\",\n  \"conf_methods\" = \"conf_index_methods_justification_reasonableness_validity_robustness\",\n  \"logic_comms\" = \"logic_communication\",\n  \"lb_logic_comms\" = \"lb_logic_communication\",\n  \"ub_logic_comms\" = \"ub_logic_communication\",\n  \"conf_logic_comms\" = \"conf_index_logic_communication\",\n  \"real_world\" = \"engaging_with_real_world_impact_quantification_practice_realism_and_relevance\",\n  \"lb_real_world\" = \"lb_engaging_with_real_world_impact_quantification_practice_realism_and_relevance\",\n  \"ub_real_world\" = \"ub_engaging_with_real_world_impact_quantification_practice_realism_and_relevance\",\n  \"conf_real_world\" = \"conf_index_engaging_with_real_world_impact_quantification_practice_realism_and_relevance\",\n  \"gp_relevance\" = \"relevance_to_global_priorities\",\n  \"lb_gp_relevance\" = \"lb_relevance_to_global_priorities\",\n  \"ub_gp_relevance\" = \"ub_relevance_to_global_priorities\",\n  \"conf_gp_relevance\" = \"conf_index_relevance_to_global_priorities\",\n  \"journal_predict\" = \"journal_quality_predict\",\n  \"lb_journal_predict\" = \"lb_journal_quality_predict\",\n  \"ub_journal_predict\" = \"ub_journal_quality_predict\",\n  \"conf_journal_predict\" = \"conf_index_journal_quality_predict\",\n  \"open_sci\" = \"open_collaborative_replicable\",\n  \"conf_open_sci\" = \"conf_index_open_collaborative_replicable\",\n  \"lb_open_sci\" = \"lb_open_collaborative_replicable\",\n  \"ub_open_sci\" = \"ub_open_collaborative_replicable\",\n  \"conf_merits_journal\" = \"conf_index_merits_journal\"\n)\n\nevals_pub <- evals_pub %>%\n  rename(!!!new_names)\n\n#  Create a list of labels with the old, longer names\nlabels <- str_replace_all(new_names, \"_\", \" \") %>% str_to_title()\n\n# Assign labels to the dataframe / tibble\n# (maybe this can be done as an attribute, not currently working)\n# for(i in seq_along(labels)) {\n#    col_name <- new_names[names(new_names)[i]]\n#    label <- labels[i]\n#    attr(evals_pub[[col_name]], \"label\") <- label\n#  }\n\n\n# expand categories into columns, unlist everything\nevals_pub %<>%\n  tidyr::unnest_wider(cat, names_sep = \"_\") %>% # give each of these its own col\n  mutate(across(everything(), unlist))  # maybe check why some of these are lists in the first place\n  \n\n# clean the Anonymous names\nevals_pub$eval_name <- ifelse(\n  grepl(\"^\\\\b\\\\w+\\\\b$|\\\\bAnonymous\\\\b\", evals_pub$eval_name),\n  paste0(\"Anonymous_\", seq_along(evals_pub$eval_name)),\n  evals_pub$eval_name\n)\n\n#housekeeping\nrm(evals)\n\n#Todo -- check the unlist is not propagating the entry\n#Note: category,  topic_subfield, and source have multiple meaningful categories. These will need care  \n\n\n\nCodeevals_pub_long <- evals_pub %>% \n  pivot_longer(cols = -c(id, crucial_rsx, paper_abbrev, eval_name, \n                         cat_1,cat_2, cat_3,source_main,author_agreement),\n               names_pattern = \"(lb_|ub_|conf_)?(.+)\",\n               names_to = c(\"value_type\", \"rating_type\")) %>% # one line per rating type\n  mutate(value_type = if_else(value_type == \"\", \"est_\", value_type)) %>% #add main rating id\n  pivot_wider(names_from = value_type, \n              values_from = value)\n\n\n\n\nReconcile uncertainty ratings and CIs\nWhere people gave only confidence level ‘dots’, we impute CIs (confidence/credible intervals). We follow the correspondence described here. (Otherwise, where they gave actual CIs, we use these.)1\n\n\n\n\n\n\nDots to interval choices\n\n\n\n\n\n\n5 = Extremely confident, i.e., 90% confidence interval spans +/- 4 points or less)\n\nFor 0-100 ratings, code the LB as \\(max(R - 4,0)\\) and the UB as \\(min(R + 4,100)\\), where R is the stated (middle) rating. This ‘scales’ the CI, as interpreted, to be proportional to the rating, with a maximum ‘interval’ of about 8, with the rating is about 96.\n\n4 = Very*confident: 90% confidence interval +/- 8 points or less\n\nFor 0-100 ratings, code the LB as \\(max(R - 8,0)\\) and the UB as \\(min(R + 8,100)\\), where R is the stated (middle) rating.\n\n3 = Somewhat** confident: 90% confidence interval +/- 15 points or less \n\n\n2 = Not very** confident: 90% confidence interval, +/- 25 points or less\n\nComparable scaling for the 2-3 ratings as for the 4 and 5 rating.\n\n1 = Not** confident: (90% confidence interval +/- more than 25 points)\n\nCode LB as \\(max(R - 37.5,0)\\) and the UB as \\(min(R + 37.5,100)\\).\nThis is just a first-pass. There might be a more information-theoretic way of doing this. On the other hand, we might be switching the evaluations to use a different tool soon, perhaps getting rid of the 1-5 confidence ratings altogether.\n\n\n\n\nreconcile explicit bounds and stated confidence level# Define the baseline widths for each confidence rating\n# JB: it would be good to have some more backing of whether this\n# is a valid way to translate these confidence levels into CIs\n\n# baseline_widths <- c(4, 8, 15, 25, 37.5)\n\n# Lists of categories\nrating_cats <- c(\"overall\", \"adv_knowledge\", \"methods\", \"logic_comms\", \"real_world\", \"gp_relevance\", \"open_sci\")\n\n#... 'predictions' are currently 1-5 (0-5?)\npred_cats <- c(\"journal_predict\", \"merits_journal\")\n\n#DR: Note that I use these objects in future chapters, but they are not connected to the data frame. Either one saves and reinputs the whole environment (messy, replicability issue), or you save this somewhere and re-input it or connect it to the data frame that gets saved (not sure how to do it), or you hard-code reinput it in the next chapter. \n\n#I do the latter for now, but I'm not happy about it, because the idea is 'input definitions in a single place to use later'\n\n#JB: I don't really understand why not just hard code it in the next chapter. These are very short strings. Do you expect them to change often? If so, we can derive them from a dataframe somewhere in the future or save as a separate object. \n\n\n# JB: Rewritten functions for adding imputed ub and lb\n\n# calculate the lower and upper bounds, \n# rating: given a rating, \n# conf: a confidence (1-5) score,\n# type: a bound type (lower, upper),\n# scale: a scale (100 is 0-100, 5 is 1-5)\n# This function is not vectorized\ncalc_bounds <- function(rating, conf, type, scale) {\n  \n  if(scale == 5){ #for the 'journal tier prediction case'\n    baseline_width = case_match(conf, \n                                5 ~ .2, #4*5/100\n                                4 ~ .4, #8*5/100\n                                3 ~ .75, #15*5/100\n                                2 ~ 1.25, #25*5/100\n                                1 ~ 1.875, #37.5*5/100\n                                .default = NA_real_) \n\n    upper = min(rating + baseline_width, 5)\n    lower = max(rating - baseline_width, 1)\n  }#/if(scale == 5)\n  \n  if(scale == 100){ #for the 'ratings case'\n    \n    baseline_width = case_match(conf, \n                                5 ~ 4, \n                                4 ~ 8, \n                                3 ~ 15, \n                                2 ~ 25, \n                                1 ~ 37.5,\n                                .default = NA_real_)\n    \n    upper = min(rating + baseline_width, 100)\n    lower = max(rating - baseline_width, 0)\n  } #/if(scale == 100)\n  \n  if(type == \"lower\") return(lower)\n  if(type == \"upper\") return(upper)\n}\n\n\n# calculate or find correct lower or upper bound\n# based on rating type, and lb, ub, and conf values\nimpute_bounds <- function(var_name, est, lb, ub, conf, bound_type) {\n  \n  # get scale of each variable\n  scale = if_else(var_name %in% c(\"journal_predict\", \"merits_journal\"), # if variable is a prediction\n                  5, 100) #scale is 5, else scale is 100\n  # if calculating lower bound variable\n  if(bound_type == \"lower\") { #we are calculating a lower bound imputation\n    # \n    calculated_bound = map_dbl(.x = est, .f = calc_bounds, conf = conf, type = bound_type, scale = scale)\n    \n    imp_bound = if_else(is.na(lb), calculated_bound, lb)\n  }\n  \n  # if calculating upper bound variable\n  if(bound_type == \"upper\") { #we are calculating an upper bound imputation\n    # \n    calculated_bound = map_dbl(.x = est, .f = calc_bounds, conf = conf, type = bound_type, scale = scale)\n    imp_bound = if_else(is.na(ub), calculated_bound, ub)\n  }\n  \n  return(imp_bound)\n}\n\n# apply functions to evals_pub_long\n# where each row is one type of rating\n# so each evaluation is 9 rows long\nevals_pub_long <- evals_pub_long %>% \n  rowwise() %>% # apply function to each row\n  mutate(lb_imp_ = impute_bounds(var_name = rating_type,\n                                   est = est_,\n                                   lb = lb_, ub = ub_, conf = conf_,\n                                   bound_type = \"lower\")) %>% \n  mutate(ub_imp_ = impute_bounds(var_name = rating_type,\n                                   est = est_,\n                                   lb = lb_, ub = ub_, conf = conf_,\n                                   bound_type = \"upper\"))\n\n# Reshape evals_pub_long into evals_pub to add imputed bounds\nevals_pub <- evals_pub_long %>% \n  pivot_wider(names_from = rating_type, # take the dataframe back to old format\n              values_from = c(est_, ub_, lb_, conf_, lb_imp_, ub_imp_),\n              names_sep = \"\") %>% \n  dplyr::rename_with(.cols = matches(\"^[ul]b_imp\"),\n                     .fn = gsub,\n                     pattern = \"(ub_imp|lb_imp)_(.+)\", \n                     replacement = \"\\\\2_\\\\1\") %>% \n  dplyr::rename_with(.cols = starts_with(\"est_\"),\n                     .fn = gsub,\n                     pattern = \"est_(.+)\",\n                     replacement = \"\\\\1\")\n\n# Clean evals_pub_long names (remove _ at end)\nevals_pub_long <- evals_pub_long %>% \n  rename_with(.cols = ends_with(\"_\"),\n              .fn = str_remove,\n              pattern = \"_$\")\n\n\nWe cannot publicly share the ‘papers under consideration’, but we can share some of the statistics on these papers. Let’s generate an ID (or later, salted hash) for each such paper, and keep only the shareable features of interest\n\nCodeall_papers_p <- all_pub_records %>% \n  dplyr::select(\n    id,\n    category,\n    cfdc_DR,\n     'confidence -- user entered',\n    cfdc_assessor,\n    avg_cfdc,\n    category,\n    cause_cat_1_text,\n    cause_cat_2_text,\n    topic_subfield_text,\n    eval_manager_text,\n    'publication status',\n    'Contacted author?',\n    'stage of process/todo',\n    'source_main',  \n    'author permission?',\n'Direct Kotahi Prize Submission?',\n    'createdTime'         \n  )\n\n\n\nCode# Create a dataset to be used as the input to a shiny app\n\n#| include: false\n#| \nevals_pub_long %>% \n  write_rds(file = here(\"shinyapp/DataExplorer\", \"shiny_explorer.rds\"))\n\n\n\nsave data for others’ useall_papers_p %>% saveRDS(file = here(\"data\", \"all_papers_p.Rdata\"))\nall_papers_p %>% write_csv(file = here(\"data\", \"all_papers_p.csv\"))\n\nevals_pub %>% saveRDS(file = here(\"data\", \"evals.Rdata\"))\nevals_pub %>% write_csv(file = here(\"data\", \"evals.csv\"))\n\nevals_pub_long %>% write_rds(file = here(\"data\", \"evals_long.rds\"))\nevals_pub_long %>% write_csv(file = here(\"data\", \"evals_long.csv\"))\n\n#evals_pub %>% readRDS(file = here(\"data\", \"evals.Rdata\"))\n\n\n\n\n\n\n\n\nNote this is only a first-pass; a more sophisticated approach may be warranted in future.↩︎"
  },
  {
    "objectID": "chapters/evaluation_data_analysis.html",
    "href": "chapters/evaluation_data_analysis.html",
    "title": "\n2  Evaluation data: description, exploration, checks\n",
    "section": "",
    "text": "load packageslibrary(tidyverse) \n\n# markdown et al. ----\nlibrary(knitr)\nlibrary(bookdown)\nlibrary(rmarkdown)\nlibrary(shiny)\nlibrary(quarto)\nlibrary(formattable) # Create 'Formattable' Data Structures\nlibrary(DT) # R interface to DataTables library (JavaScript)\n\n# dataviz ----\nlibrary(ggrepel)\nlibrary(plotly) # Create Interactive Web Graphics via 'plotly.js'\n\n# others ----\nlibrary(here) # A Simpler Way to Find Your Files\n# renv::install(packages = \"metamelb-repliCATS/aggreCAT\")\n#library(aggreCAT)\n\n# Make sure select is always the dplyr version\nselect <- dplyr::select \n\n# options\noptions(knitr.duplicate.label = \"allow\")\noptions(mc.cores = parallel::detectCores())\n\n\n\n\n\n\n\n\nNote on data input (10-Aug-23)\n\n\n\n\n\nBelow, the evaluation data is input from an Airtable, which itself was largely hand-input from evaluators’ reports. As PubPub builds (target: end of Sept. 2023), this will allow us to include the ratings and predictions as structured data objects. We then plan to access and input this data directly from the PubPub (API?) into the present analysis. This will improve automation and limit the potential for data entry errors.\n\n\n\n\nInput evaluation dataevals_pub <- readRDS(file = here(\"data\", \"evals.Rdata\"))\nall_papers_p <- readRDS(file = here(\"data\", \"all_papers_p.Rdata\"))\n\n\n\nDefine lists of columns to use later# Lists of categories\nrating_cats <- c(\"overall\", \"adv_knowledge\", \"methods\", \"logic_comms\", \"real_world\", \"gp_relevance\", \"open_sci\")\n\n#... 'predictions' are currently 1-5 (0-5?)\npred_cats <- c(\"journal_predict\", \"merits_journal\")"
  },
  {
    "objectID": "chapters/evaluation_data_analysis.html#basic-presentation",
    "href": "chapters/evaluation_data_analysis.html#basic-presentation",
    "title": "\n2  Evaluation data: description, exploration, checks\n",
    "section": "\n2.2 Basic presentation",
    "text": "2.2 Basic presentation\nWhat sorts of papers/projects are we considering and evaluating?\nIn this section, we give some simple data summaries and visualizations, for a broad description of The Unjournal’s coverage.\nIn the interactive table below we give some key attributes of the papers and the evaluators.\n\n\nCodeevals_pub_df_overview <- evals_pub %>%\n  arrange(paper_abbrev, eval_name) %>%\n  dplyr::select(paper_abbrev, crucial_rsx, eval_name, cat_1, cat_2, source_main, author_agreement) %>%\n  dplyr::select(-matches(\"ub_|lb_|conf\")) \n\nevals_pub_df_overview %>%   \n   rename(\n    \"Paper Abbreviation\" = paper_abbrev,\n    \"Paper name\" = crucial_rsx,\n    \"Evaluator Name\" = eval_name,\n    \"Main category\" = cat_1,\n    \"Category 2\" = cat_2,\n    \"Main source\" = source_main,\n    \"Author contact\" = author_agreement,\n  ) %>% \n  DT::datatable(\n    caption = \"Evaluations (confidence bounds not shown)\", \n    filter = 'top',\n    rownames= FALSE,\n    options = list(pageLength = 5,\n      columnDefs = list(list(width = '150px', targets = 1)))) %>% \n  formatStyle(columns = 2:ncol(evals_pub_df_overview), \n              textAlign = 'center') %>% \nformatStyle(\n    \"Paper name\",\n    fontSize = '10px'\n  )\n\n\n\n\n\nCoderm(evals_pub_df_overview)\n\n\n\n\nEvaluation metrics (ratings)\n\nCoderename_dtstuff <- function(df){\n  df %>%  \n  rename(\n    \"Paper Abbreviation\" = paper_abbrev,\n    \"Evaluator Name\" = eval_name,\n    \"Advancing knowledge\" = adv_knowledge,\n    \"Methods\" = methods,\n    \"Logic & comm.\" = logic_comms,\n    \"Real world engagement\" = real_world,\n    \"Global priorities relevance\" = gp_relevance,\n    \"Open Science\" = open_sci\n  )\n}\n\n\n\n\nCode# Need to find a way to control column width but it seems to be a problem with DT\n# https://github.com/rstudio/DT/issues/29\n\n\nevals_pub_df <- evals_pub %>%\n  # Arrange data\n  arrange(paper_abbrev, eval_name, overall) %>%\n  \n  # Select and rename columns\n  dplyr::select(paper_abbrev, eval_name, all_of(rating_cats)) %>%\n rename_dtstuff \n\n\n(\n evals_pub_dt <- evals_pub_df %>%  \n  # Convert to a datatable and apply styling\n  datatable(\n    caption = \"Evaluations and predictions (confidence bounds not shown)\", \n    filter = 'top',\n    rownames = FALSE,\n    options = list(pageLength = 5, \n            columnDefs = list(list(width = '150px', targets = 0)))) %>% \n  formatStyle(columns = 2:ncol(evals_pub_df), \n              textAlign = 'center')\n)\n\n\n\n\n\n\n\n\nNext, a preview of the evaluations, focusing on the ‘middle ratings and predictions’:\n\n\nData datable (all shareable relevant data)# we didn't seem to be using all_evals_dt so I removed it to increase readability\n\n\nevals_pub %>%\n  arrange(paper_abbrev, eval_name, overall) %>%\n  dplyr::select(paper_abbrev, eval_name, all_of(rating_cats))  %>%\n  rename_dtstuff %>%  \n  DT::datatable(\n    caption = \"Evaluations and predictions (confidence bounds not shown)\", \n    filter = 'top',\n    rownames= FALSE,\n    options = list(pageLength = 5,\n                  columnDefs = list(list(width = '150px', targets = 0))) \n\n    )\n\n\n\n\n\n\n\n \n\n\nCode# we did not seem to be using all_evals_dt_ci so I removed it to improve readability\nevals_pub %>%\n  arrange(paper_abbrev, eval_name) %>%\n  dplyr::select(paper_abbrev, eval_name, conf_overall, all_of(rating_cats), matches(\"ub_imp|lb_imp\")) %>%\n  rename_dtstuff %>% \n  DT::datatable(\n    caption = \"Evaluations and (imputed*) confidence bounds)\", \n    filter = 'top',\n    rownames= FALSE,\n    options = list(pageLength = 5)\n    )\n\n\n:::\n\n\n\n\n\n\nNext consider…\n\n\n\n\n\n\nComposition of research evaluated\n\nBy field (economics, psychology, etc.)\nBy subfield of economics\nBy topic/cause area (Global health, economic development, impact of technology, global catastrophic risks, etc. )\nBy source (submitted, identified with author permission, direct evaluation)\n\n\nTiming of intake and evaluation1\n\n\n\n\n\nPaper selection\nThe Sankey diagram below starts with the papers we prioritized for likely Unjournal evaluation:2.\n\nCode#Add in the 3 different evaluation input sources\n#update to be automated rather than hard-coded - to look at David's work here\n\npapers_considered <- all_papers_p %>% \n  nrow()\n\npapers_deprio <- all_papers_p %>% \n  filter(`stage of process/todo` ==  \"de-prioritized\") %>% \n  nrow()\n\npapers_evaluated <- all_papers_p %>% \n  filter(`stage of process/todo` %in% c(\"published\",\n                                        \"contacting/awaiting_authors_response_to_evaluation\",\n                                        \"awaiting_publication_ME_comments\",\"awaiting_evaluations\")) %>% \n  nrow()\n\npapers_complete <- all_papers_p %>% \n  filter(`stage of process/todo` ==  \"published\") %>%\n  nrow()\n\npapers_in_progress <-  papers_evaluated - papers_complete\n\npapers_still_in_consideration <-  all_papers_p %>% filter(`stage of process/todo` ==  \"considering\") %>% nrow()\n\n\n#todo: adjust wording of hover notes ('source, target...etc')\n\nfig <- plot_ly(\n  type = \"sankey\",\n  orientation = \"h\",\n  \n  node = list(\n    label = c(\"Prioritized\", \"Evaluating\", \"Complete\", \"In progress\", \"Still in consideration\", \"De-prioritized\"),\n    color = c(\"orange\", \"green\", \"green\", \"orange\", \"orange\", \"red\"),\n    #Todo: adjust 'location' to group these left to right\n    pad = 15,\n    thickness = 20,\n    line = list(\n      color = \"black\",\n      width = 0.5\n    )\n  ),\n  \n  link = list(\n    source = c(0,1,1,0,0),\n    target = c(1,2,3,4,5),\n    value =  c(\n      papers_evaluated,\n      papers_complete,\n      papers_in_progress,\n      papers_still_in_consideration,\n      papers_deprio\n    ))\n)\nfig <- fig %>% layout(\n  title = \"Unjournal paper funnel\",\n  font = list(\n    size = 10\n  )\n)\n\nfig \n\n\n\n\n\nTodo: 3\nPaper categories\n\nCodeevals_pub %>% \n  select(paper_abbrev, starts_with(\"cat_\")) %>%\n  distinct() %>% \n  pivot_longer(cols = starts_with(\"cat_\"), names_to = \"CatNum\", values_to = \"Category\") %>% \n  group_by(CatNum, Category) %>% \n  count() %>% \n  filter(!is.na(Category)) %>% \n  mutate(Category = str_to_title(Category),\n         CatNum = ordered(CatNum, \n                          levels = c(\"cat_1\", \"cat_2\", \"cat_3\"),\n                          labels = c(\"Primary\", \"Secondary\", \"Tertiary\"))) %>%\n  ggplot(aes(x = reorder(Category, -n), y = n)) +\n  geom_bar(aes(fill = CatNum), stat = \"identity\", color = \"grey30\") + \n  labs(x = \"Paper category\", y = \"Count\", fill = \"Cat Level\",\n       title = \"Paper categories represented in pilot data\") +\n  theme_bw() +\n  facet_grid(~CatNum, scales=\"free_x\", space=\"free_x\") +\n  theme(axis.text.x=element_text(angle=45,hjust=1)) +\n  theme(legend.position = \"none\")\n\n\n\n\nPaper source\n\nCode# Bar plot\nevals_pub %>% \n  rowwise() %>% \n  mutate(source_main = str_replace_all(string = source_main, \n                                       pattern = \"-\", \n                                       replace = \" \") %>% str_to_title()) %>%\n  select(paper_abbrev, source_main) %>% \n  distinct() %>%\n  ggplot(aes(x = source_main)) + \n  geom_bar(position = \"stack\", stat = \"count\", color = \"grey30\", fill = \"grey80\") +\n  labs(x = \"Source\", y = \"Count\") +\n  labs(title = \"Pool of research/evaluations by paper source\") +\n  theme_bw() +\n  theme(text = element_text(size = 15)) +\n  scale_x_discrete(labels = function(x) str_wrap(x, width = 20))\n\n\n\n\n\nCode# JB: Most of these should probably be cleaned in data storage\n\nlibrary(RColorBrewer)  # for color palettes\n\n# paper statuses that are considered \"being evaluated\"\neval_true = c(\"published\", \n              \"contacting/awaiting_authors_response_to_evaluation\",\n              \"awaiting_publication_ME_comments\",\n              \"awaiting_evaluations\")\n\n# Is the paper being evaluated? \nall_papers_p <- all_papers_p %>% \n  mutate(is_evaluated = if_else(`stage of process/todo` %in% eval_true, TRUE, FALSE))\n\n# main source clean\nall_papers_p <- all_papers_p %>% \n  mutate(source_main = case_when(source_main == \"NA\" ~ \"Not applicable\",\n                                 source_main == \"internal-from-syllabus-agenda-policy-database\" ~ \"Internal: syllabus, agenda, etc.\",\n                                 is.na(source_main) ~ \"Unknown\",\n                                 TRUE ~ source_main))\n\nall_papers_p %>% \nggplot(aes(x = fct_infreq(source_main), fill = is_evaluated)) + \n  geom_bar(position = \"stack\", stat = \"count\") +\n  labs(x = \"Source\", y = \"Count\", fill = \"Selected for\\nevaluation?\") +\n  coord_flip() + # flipping the coordinates to have categories on y-axis (on the left)\n  labs(title = \"Evaluations by source of the paper\") +\n  theme_bw() +\n  theme(text = element_text(size = 15)) +\n  scale_fill_brewer(palette = \"Set1\") +\n  scale_x_discrete(labels = function(x) str_wrap(x, width = 20))"
  },
  {
    "objectID": "chapters/evaluation_data_analysis.html#the-distribution-of-ratings-and-predictions",
    "href": "chapters/evaluation_data_analysis.html#the-distribution-of-ratings-and-predictions",
    "title": "\n2  Evaluation data: description, exploration, checks\n",
    "section": "The distribution of ratings and predictions",
    "text": "The distribution of ratings and predictions\nNext, we present the ratings and predictions along with ‘uncertainty measures’.4 Where evaluators gave only a 1-5 confidence level5, we use the imputations discussed and coded above.\n\nFor each category and prediction (overall and by paper)\n\n\nCode# evals_pub %>% \n#   select(matches(\"overall\")) %>% \n#   view()\n\n\n\n\nCode# Generate a color palette with more colors\ncolor_count <- length(unique(evals_pub$paper_abbrev))\ncolor_palette <- colorRampPalette(brewer.pal(8, \"Set1\"))(color_count)\n\n# set one \"set\" of dodge width values across layers\npd = position_dodge(width = 0.8)\n\n# Dot plot\ng1 <- evals_pub %>% \n  ggplot(aes(x = paper_abbrev, y = overall, \n             text = paste0('Evaluator: ', eval_name,   # tooltip data\n                           '<br>Rating [CI]: ', overall, \" [\", overall_lb_imp, \", \", overall_ub_imp, \"]\"))) +\n  geom_point(aes(color = paper_abbrev), \n             stat = \"identity\", size = 2, shape = 18, stroke = 1, \n             position = pd) +\n  geom_linerange(aes(ymin = overall_lb_imp, ymax = overall_ub_imp, color = paper_abbrev), \n                 position = pd) +\n  geom_text(data = subset(evals_pub, str_detect(eval_name, \"Anonymous\")),\n            aes(label = \"anon.\"), size=3) +\n  coord_flip() + # flipping the coordinates to have categories on y-axis (on the left)\n  labs(x = \"Paper\", y = \"Overall score\",\n       title = \"Overall scores of evaluated papers\") +\n  theme_bw() +\n  theme(text = element_text(size = 15)) +\n  theme(legend.position = \"none\") +\n  scale_x_discrete(labels = function(x) str_wrap(x, width = 20)) + \n    scale_color_manual(values = color_palette)\n\n\nggplotly(g1, tooltip = c(\"text\"))\n\n\n\n\n\n\nIn future, we aim to build a dashboard allowing people to use the complete set of ratings and predictions, and choose their own weightings. (Also incorporating the evaluator uncertainty in reasonable ways.)\nShiny dashboard\n\n\n \n\n\n\n\n\n\n\n\nFuture vis\n\n\n\n\n\nSpider or radial chart\nEach rating is a dimension or attribute (potentially normalized) potentially superimpose a ‘circle’ for the suggested weighting or overall.\nEach paper gets its own spider, with all others (or the average) in faded color behind it as a comparator.\nIdeally user can switch on/off\nBeware – people infer things from the shape’s size\n\n\n\n\n\nCode# JB: what is the purpose of this table? It's very large and I'm not totally\n# sure what it's doing so I'm just turning it off for now\nunit.scale = function(x) (x*100 - min(x*100)) / (max(x*100) - min(x*100))\n\nevaluations_table <- evals_pub %>%\n  select(paper_abbrev, eval_name, cat_1, \n         source_main, overall, adv_knowledge,\n         methods, logic_comms, journal_predict) %>%\n  arrange(desc(paper_abbrev))\n\nformattable(\n  evaluations_table,\n  list(\n    #area(col = 5:8) ~ function(x) percent(x / 100, digits = 0),\n    area(col = 5:8) ~ color_tile(\"#FA614B66\",\"#3E7DCC\"),\n    `journal_predict` = proportion_bar(\"#DeF7E9\", unit.scale)\n  )\n)\n\n\n\nSources of variation\nNext, look for systematic variation in the ratings\n\nBy field and topic area of paper\nBy submission/selection route\nBy evaluation manager (or their seniority, or whether they are US/Commonwealth/Other)6\n\n… perhaps building a model of this. We are looking for systematic ‘biases and trends’, loosely speaking, to help us better understand how our evaluation system is working.\n\nRelationship among the ratings (and predictions)\n\n\n\n\n\n\nNext steps (suggested analyses)\n\n\n\n\n\n\nCorrelation matrix\nANOVA\nPCA (Principle components)\nWith other ‘control’ factors?\n\nHow do the specific measures predict the aggregate ones (overall rating, merited publication)\n\nCF ‘our suggested weighting’\n\n\n\n\n\n\nNext chapter (analysis): aggregation of evaluator judgment\n\n\n\n\n\n\nScoping our future coverage\n\n\n\n\n\nWe have funding to evaluate roughly 50-70 papers/projects per year, given our proposed incentives.\nConsider:\n\nHow many relevant NBER papers come out per year?\nHow much relevant work in other prestige archives?\nWhat quotas do we want (by cause, etc.) and how feasible are these?"
  },
  {
    "objectID": "chapters/aggregation.html",
    "href": "chapters/aggregation.html",
    "title": "\n3  Aggregation of evaluators judgments (modeling)\n",
    "section": "",
    "text": "Hanea et al\n\n\n\n\n\n(Consult, e.g., repliCATS/Hanea and others work; meta-science and meta-analysis approaches)\naggrecat package\n\nAlthough the accuracy, calibration, and informativeness of the majority of methods are very similar, a couple of the aggregation methods consistently distinguish themselves as among the best or worst. Moreover, the majority of methods outperform the usual benchmarks provided by the simple average or the median of estimates.\n\nHanea et al, 2021\nHowever, these are in a different context. Most of those measures are designed to deal with probablistic forecasts for binary outcomes, where the predictor also gives a ‘lower bound’ and ‘upper bound’ for that probability. We could roughly compare that to our continuous metrics with 90% CI’s (or imputations for these).\nFurthermore, many (all their successful measures?) use ‘performance-based weights’, accessing metrics from prior prediction performance of the same forecasters We do not have these, nor do we have a sensible proxy for this.\n\n\n\n\n\n\n\n\n\nD Veen et al (2017)\n\n\n\n\n\nlink\n… we show how experts can be ranked based on their knowledge and their level of (un)certainty. By letting experts specify their knowledge in the form of a probability distribution, we can assess how accurately they can predict new data, and how appropriate their level of (un)certainty is. The expert’s specified probability distribution can be seen as a prior in a Bayesian statistical setting. We evaluate these priors by extending an existing prior-data (dis)agreement measure, the Data Agreement Criterion, and compare this approach to using Bayes factors to assess prior specification. We compare experts with each other and the data to evaluate their appropriateness. Using this method, new research questions can be asked and answered, for instance: Which expert predicts the new data best? Is there agreement between my experts and the data? Which experts’ representation is more valid or useful? Can we reach convergence between expert judgement and data? We provided an empirical example ranking (regional) directors of a large financial institution based on their predictions of turnover.\nBe sure to consult the correction made here\n\n\n\n\n\n\n\n\n\nAlso seems relevant:\n\n\n\n\n\nSee Gsheet HERE, generated from an Elicit.org inquiry.\n\n\n\nIn spite of the caveats in the fold above, we construct some measures of aggregate beliefs using the aggrecat package. We will make (and explain) some ad-hoc choices here. We present these:\n\nFor each paper\nFor categories of papers and cross-paper categories of evaluations\nFor the overall set of papers and evaluations\n\nWe can also hold onto these aggregated metrics for later use in modeling.\n\nSimple averaging\nBayesian approaches\nBest-performing approaches from elsewhere\nAssumptions over unit-level random terms\n\n\nBelow, we are preparing the data for the aggreCATS package.\n\nCode# JB: This section is a work in progress, please do not edit\n\n# paper_ratings: one row per rating category and 'type' (score, upper, lower bound.)\nevals_pub %>% \n  select(id, eval_name, paper_abbrev, \n         overall, overall_lb_imp, overall_ub_imp,\n         adv_knowledge, adv_knowledge_lb_imp, adv_knowledge_ub_imp,\n         methods, methods_lb_imp, methods_ub_imp,\n         logic_comms, logic_comms_lb_imp, logic_comms_ub_imp,\n         real_world, real_world_lb_imp, real_world_ub_imp,\n         gp_relevance, gp_relevance_lb_imp, gp_relevance_ub_imp,\n         open_sci, open_sci_lb_imp, open_sci_ub_imp) %>% \n  rename_with(function(x) paste0(x,\"_score\"), all_of(rating_cats)) %>%\n  pivot_longer(cols = c(-id, -eval_name, -paper_abbrev),\n              names_pattern = \"(.+)_(score|[ul]b_imp)\",\n              names_to = c(\"criterion\",\"element\"),\n              values_to = \"value\") -> paper_ratings\n\n# renaming to conform with aggreCATS expectations\npaper_ratings <- paper_ratings %>% \n  rename(paper_id = paper_abbrev,\n         user_name = eval_name) %>% \n  mutate(round = \"round_1\",\n         element = case_when(element == \"lb_imp\" ~ \"three_point_lower\",\n                             element == \"ub_imp\" ~ \"three_point_upper\",\n                             element == \"score\" ~ \"three_point_best\"))\n\n# filter only overall for now\npaper_ratings %>% \n  filter(criterion == \"overall\") %>% \n  group_by(user_name, paper_id) %>% \n  filter(sum(is.na(value))==0) %>% \n  ungroup() -> temp\n  \n\nAverageWAgg(expert_judgements = temp, round_2_filter = FALSE, type = \"ArMean\")\n\nIntervalWAgg(expert_judgements = temp, round_2_filter = FALSE, type = \"IntWAgg\")\n\naggreCAT::DistributionWAgg(expert_judgements = temp, round_2_filter = FALSE, type = \"DistribArMean\", percent_toggle = T)\n\n# EXAMPLE CODE ===============================\n# data(data_ratings)\n# set.seed(1234)\n# \n# participant_subset <- data_ratings %>%\n#   distinct(user_name) %>%\n#   sample_n(5) %>%\n#   mutate(participant_name = paste(\"participant\", rep(1:n())))\n# \n# single_claim <- data_ratings %>%\n#   filter(paper_id == \"28\") %>%\n#   right_join(participant_subset, by = \"user_name\") %>%\n#   filter(grepl(x = element, pattern = \"three_.+\")) %>%\n#   select(-group, -participant_name, -question)\n# \n# DistributionWAgg(expert_judgements = single_claim,\n#             type = \"DistribArMean\", percent_toggle = T)\n# \n\n\n\n\nUse the above aggregation as the outcome of interest, or weight towards categories of greater interest?\nModel with controls – look for greatest positive residual?"
  },
  {
    "objectID": "chapters/aggregation.html#inter-rater-reliability",
    "href": "chapters/aggregation.html#inter-rater-reliability",
    "title": "\n3  Aggregation of evaluators judgments (modeling)\n",
    "section": "\n3.2 Inter-rater reliability",
    "text": "3.2 Inter-rater reliability"
  },
  {
    "objectID": "chapters/aggregation.html#decomposing-variation-dimension-reduction-simple-linear-models",
    "href": "chapters/aggregation.html#decomposing-variation-dimension-reduction-simple-linear-models",
    "title": "\n3  Aggregation of evaluators judgments (modeling)\n",
    "section": "\n3.3 Decomposing variation, dimension reduction, simple linear models",
    "text": "3.3 Decomposing variation, dimension reduction, simple linear models"
  },
  {
    "objectID": "chapters/aggregation.html#later-possiblities",
    "href": "chapters/aggregation.html#later-possiblities",
    "title": "\n3  Aggregation of evaluators judgments (modeling)\n",
    "section": "\n3.4 Later possiblities",
    "text": "3.4 Later possiblities\n\nRelation to evaluation text content (NLP?)\nRelation/prediction of later outcomes (traditional publication, citations, replication)"
  }
]