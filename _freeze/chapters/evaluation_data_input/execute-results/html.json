{
  "hash": "277e29db7636d48cb1181043b31e3b57",
  "result": {
    "markdown": "# Evaluation data: input/features\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"load packages\"}\nlibrary(tidyverse) \n\n# data acquisition ----\n#devtools::install_github(\"bergant/airtabler\")\nlibrary(airtabler)\n\n# data cleaning & shaping ----\n\n# data analysis ----\n# library(lme4)\n# library(lmtest) # Testing Linear Regression Models\n\n# markdown et al. ----\nlibrary(knitr)\nlibrary(bookdown)\nlibrary(quarto)\nlibrary(formattable) # Create 'Formattable' Data Structures\n\n# others ----\nlibrary(here) # A Simpler Way to Find Your Files\n#devtools::install_github(\"metamelb-repliCATS/aggreCAT\")\nlibrary(aggreCAT)\n\n# Make sure select is always the dplyr version\nselect <- dplyr::select \n\n# source DistributionWAggMOD\nsource(here(\"code\", \"DistAggModified.R\"))\n\n# options\noptions(knitr.duplicate.label = \"allow\")\n```\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Note on data input (10-Aug-23)\n\nBelow, the evaluation data is input from an Airtable, which itself was largely hand-input from evaluators' reports. As PubPub builds (target: end of Sept. 2023), this will allow us to  include the ratings and predictions as structured data objects. We then plan to access and input this data *directly* from the PubPub (API?) into the present analysis. This will improve automation and limit the potential for data entry errors.\n\n::: \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"input from airtable\"}\n#base_id <- \"appbPYEw9nURln7Qg\"\nbase_id <- \"applDG6ifmUmeEJ7j\" #new ID to cover \"UJ - research & core members\" base\n\n\n# Set your Airtable API key \nSys.setenv(AIRTABLE_API_KEY = Sys.getenv(\"AIRTABLE_API_KEY\"))\n#this should be set in my .Renviron file\n\n# Read data from a specific view\n\nevals <- air_get(base = base_id, \"output_eval\") \n\nall_pub_records <- data.frame()\npub_records <- air_select(base = base_id, table = \"crucial_rsx\")\n\n# Append the records to the list\nall_pub_records <- bind_rows(all_pub_records, pub_records)\n\n# While the length of the records list is 100 (the maximum), fetch more records\nwhile(nrow(pub_records) == 100) {\n  # Get the ID of the last record in the list\n  offset <- get_offset(pub_records)\n  \n  # Fetch the next 100 records, starting after the last ID\n  pub_records <- air_select(base = base_id, table = \"crucial_rsx\", offset =  offset)\n  \n  # Append the records to the df\n  all_pub_records <- bind_rows(all_pub_records, pub_records)\n}\n\n# housekeeping\nrm(pub_records)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"just the useful and publish-able data, clean a bit\"}\n# clean evals names to snakecase\ncolnames(evals) <- snakecase::to_snake_case(colnames(evals))\n\nevals_pub <- evals %>% \n  dplyr::rename(stage_of_process = stage_of_process_todo_from_crucial_research_2) %>% \n  mutate(stage_of_process = unlist(stage_of_process)) %>% \n  dplyr::filter(stage_of_process == \"published\") %>% \n    select(id, \n           crucial_research, \n           paper_abbrev, \n           evaluator_name, \n           category, \n           source_main, \n           author_agreement, \n           overall, \n           lb_overall, \n           ub_overall, \n           conf_index_overall, \n           advancing_knowledge_and_practice, \n           lb_advancing_knowledge_and_practice, \n           ub_advancing_knowledge_and_practice, \n           conf_index_advancing_knowledge_and_practice,\n           methods_justification_reasonableness_validity_robustness,\n           lb_methods_justification_reasonableness_validity_robustness,\n           ub_methods_justification_reasonableness_validity_robustness,\n           conf_index_methods_justification_reasonableness_validity_robustness, \n           logic_communication, lb_logic_communication, ub_logic_communication, \n           conf_index_logic_communication,\n           engaging_with_real_world_impact_quantification_practice_realism_and_relevance,\n           lb_engaging_with_real_world_impact_quantification_practice_realism_and_relevance,\n           ub_engaging_with_real_world_impact_quantification_practice_realism_and_relevance,\n           conf_index_engaging_with_real_world_impact_quantification_practice_realism_and_relevance,\n           relevance_to_global_priorities, \n           lb_relevance_to_global_priorities, \n           ub_relevance_to_global_priorities, \n           conf_index_relevance_to_global_priorities, \n           journal_quality_predict, \n           lb_journal_quality_predict, \n           ub_journal_quality_predict,\n           conf_index_journal_quality_predict, \n           open_collaborative_replicable, \n           conf_index_open_collaborative_replicable, \n           lb_open_collaborative_replicable, \n           ub_open_collaborative_replicable, \n           merits_journal, \n           lb_merits_journal, \n           ub_merits_journal, \n           conf_index_merits_journal)\n\n# shorten names (before you expand into columns)\nnew_names <- c(\n  \"eval_name\" = \"evaluator_name\",\n  \"cat\" = \"category\",\n  \"crucial_rsx\" = \"crucial_research\",\n  \"conf_overall\" = \"conf_index_overall\",\n  \"adv_knowledge\" = \"advancing_knowledge_and_practice\",\n  \"lb_adv_knowledge\" = \"lb_advancing_knowledge_and_practice\",\n  \"ub_adv_knowledge\" = \"ub_advancing_knowledge_and_practice\",\n  \"conf_adv_knowledge\" = \"conf_index_advancing_knowledge_and_practice\",\n  \"methods\" = \"methods_justification_reasonableness_validity_robustness\",\n  \"lb_methods\" = \"lb_methods_justification_reasonableness_validity_robustness\",\n  \"ub_methods\" = \"ub_methods_justification_reasonableness_validity_robustness\",\n  \"conf_methods\" = \"conf_index_methods_justification_reasonableness_validity_robustness\",\n  \"logic_comms\" = \"logic_communication\",\n  \"lb_logic_comms\" = \"lb_logic_communication\",\n  \"ub_logic_comms\" = \"ub_logic_communication\",\n  \"conf_logic_comms\" = \"conf_index_logic_communication\",\n  \"real_world\" = \"engaging_with_real_world_impact_quantification_practice_realism_and_relevance\",\n  \"lb_real_world\" = \"lb_engaging_with_real_world_impact_quantification_practice_realism_and_relevance\",\n  \"ub_real_world\" = \"ub_engaging_with_real_world_impact_quantification_practice_realism_and_relevance\",\n  \"conf_real_world\" = \"conf_index_engaging_with_real_world_impact_quantification_practice_realism_and_relevance\",\n  \"gp_relevance\" = \"relevance_to_global_priorities\",\n  \"lb_gp_relevance\" = \"lb_relevance_to_global_priorities\",\n  \"ub_gp_relevance\" = \"ub_relevance_to_global_priorities\",\n  \"conf_gp_relevance\" = \"conf_index_relevance_to_global_priorities\",\n  \"journal_predict\" = \"journal_quality_predict\",\n  \"lb_journal_predict\" = \"lb_journal_quality_predict\",\n  \"ub_journal_predict\" = \"ub_journal_quality_predict\",\n  \"conf_journal_predict\" = \"conf_index_journal_quality_predict\",\n  \"open_sci\" = \"open_collaborative_replicable\",\n  \"conf_open_sci\" = \"conf_index_open_collaborative_replicable\",\n  \"lb_open_sci\" = \"lb_open_collaborative_replicable\",\n  \"ub_open_sci\" = \"ub_open_collaborative_replicable\",\n  \"conf_merits_journal\" = \"conf_index_merits_journal\"\n)\n\nevals_pub <- evals_pub %>%\n  rename(!!!new_names)\n\n#  Create a list of labels with the old, longer names\nlabels <- str_replace_all(new_names, \"_\", \" \") %>% str_to_title()\n\n# Assign labels to the dataframe / tibble\n# (maybe this can be done as an attribute, not currently working)\n# for(i in seq_along(labels)) {\n#    col_name <- new_names[names(new_names)[i]]\n#    label <- labels[i]\n#    attr(evals_pub[[col_name]], \"label\") <- label\n#  }\n\n\n# expand categories into columns, unlist everything\nevals_pub %<>%\n  tidyr::unnest_wider(cat, names_sep = \"_\") %>% # give each of these its own col\n  mutate(across(everything(), unlist))  # maybe check why some of these are lists in the first place\n  \n\n# clean the Anonymous names\nevals_pub$eval_name <- ifelse(\n  grepl(\"^\\\\b\\\\w+\\\\b$|\\\\bAnonymous\\\\b\", evals_pub$eval_name),\n  paste0(\"Anonymous_\", seq_along(evals_pub$eval_name)),\n  evals_pub$eval_name\n)\n\n#housekeeping\nrm(evals)\n\n#Todo -- check the unlist is not propagating the entry\n#Note: category,  topic_subfield, and source have multiple meaningful categories. These will need care  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nevals_pub_long <- evals_pub %>% \n  pivot_longer(cols = -c(id, crucial_rsx, paper_abbrev, eval_name, \n                         cat_1,cat_2, cat_3,source_main,author_agreement),\n               names_pattern = \"(lb_|ub_|conf_)?(.+)\",\n               names_to = c(\"value_type\", \"rating_type\")) %>% # one line per rating type\n  mutate(value_type = if_else(value_type == \"\", \"est_\", value_type)) %>% #add main rating id\n  pivot_wider(names_from = value_type, \n              values_from = value)\n```\n:::\n\n\n\n<!-- need airtable API stuff -->\n\n### Reconcile uncertainty ratings and CIs {-}\n\nWhere people gave only confidence level 'dots', we impute CIs (confidence/credible intervals). We follow the correspondence described [here](https://effective-giving-marketing.gitbook.io/unjournal-x-ea-and-global-priorities-research/policies-projects-evaluation-workflow/evaluation/guidelines-for-evaluators#1-5-dots-explanation-and-relation-to-cis). (Otherwise, where they gave actual CIs, we use these.)^[Note this is only a first-pass; a more sophisticated approach may be warranted in future.]\n\n::: {.callout-note collapse=\"true\"}\n## Dots to interval choices\n\n> 5 = Extremely confident, i.e., 90% confidence interval spans +/- 4 points or less)\n\nFor 0-100 ratings, code the LB as $max(R - 4,0)$ and the UB as $min(R + 4,100)$, where R is the stated (middle) rating. This 'scales' the CI, as interpreted, to be proportional to the rating, with a  maximum 'interval' of about 8, with the rating is about 96.\n\n> 4 = Very*confident: 90% confidence interval +/- 8 points or less\n\nFor 0-100 ratings, code the LB as $max(R - 8,0)$ and the UB as $min(R + 8,100)$, where R is the stated (middle) rating. \n\n> 3 = Somewhat** confident: 90% confidence interval +/- 15 points or less&#x20;\n\n> 2 = Not very** confident: 90% confidence interval, +/- 25 points or less\n\nComparable scaling for the 2-3 ratings as for the 4 and 5 rating.\n\n> 1 = Not** confident: (90% confidence interval +/- more than 25 points)\n    \nCode LB as $max(R - 37.5,0)$ and the UB as $min(R + 37.5,100)$. \n    \nThis is just a first-pass. There might be a more information-theoretic way of doing this. On the other hand, we might be switching the evaluations to use a different tool soon, perhaps getting rid of the 1-5 confidence ratings altogether.\n\n::: \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"reconcile explicit bounds and stated confidence level\"}\n# Define the baseline widths for each confidence rating\n# JB: it would be good to have some more backing of whether this\n# is a valid way to translate these confidence levels into CIs\n\n# baseline_widths <- c(4, 8, 15, 25, 37.5)\n\n# Lists of categories\nrating_cats <- c(\"overall\", \"adv_knowledge\", \"methods\", \"logic_comms\", \"real_world\", \"gp_relevance\", \"open_sci\")\n\n#... 'predictions' are currently 1-5 (0-5?)\npred_cats <- c(\"journal_predict\", \"merits_journal\")\n\n#DR: Note that I use these objects in future chapters, but they are not connected to the data frame. Either one saves and reinputs the whole environment (messy, replicability issue), or you save this somewhere and re-input it or connect it to the data frame that gets saved (not sure how to do it), or you hard-code reinput it in the next chapter. \n\n#I do the latter for now, but I'm not happy about it, because the idea is 'input definitions in a single place to use later'\n\n#JB: I don't really understand why not just hard code it in the next chapter. These are very short strings. Do you expect them to change often? If so, we can derive them from a dataframe somewhere in the future or save as a separate object. \n\n\n# JB: Rewritten functions for adding imputed ub and lb\n\n# calculate the lower and upper bounds, \n# rating: given a rating, \n# conf: a confidence (1-5) score,\n# type: a bound type (lower, upper),\n# scale: a scale (100 is 0-100, 5 is 1-5)\n# This function is not vectorized\ncalc_bounds <- function(rating, conf, type, scale) {\n  \n  if(scale == 5){ #for the 'journal tier prediction case'\n    baseline_width = case_match(conf, \n                                5 ~ .2, #4*5/100\n                                4 ~ .4, #8*5/100\n                                3 ~ .75, #15*5/100\n                                2 ~ 1.25, #25*5/100\n                                1 ~ 1.875, #37.5*5/100\n                                .default = NA_real_) \n\n    upper = min(rating + baseline_width, 5)\n    lower = max(rating - baseline_width, 1)\n  }#/if(scale == 5)\n  \n  if(scale == 100){ #for the 'ratings case'\n    \n    baseline_width = case_match(conf, \n                                5 ~ 4, \n                                4 ~ 8, \n                                3 ~ 15, \n                                2 ~ 25, \n                                1 ~ 37.5,\n                                .default = NA_real_)\n    \n    upper = min(rating + baseline_width, 100)\n    lower = max(rating - baseline_width, 0)\n  } #/if(scale == 100)\n  \n  if(type == \"lower\") return(lower)\n  if(type == \"upper\") return(upper)\n}\n\n\n# calculate or find correct lower or upper bound\n# based on rating type, and lb, ub, and conf values\nimpute_bounds <- function(var_name, est, lb, ub, conf, bound_type) {\n  \n  # get scale of each variable\n  scale = if_else(var_name %in% c(\"journal_predict\", \"merits_journal\"), # if variable is a prediction\n                  5, 100) #scale is 5, else scale is 100\n  # if calculating lower bound variable\n  if(bound_type == \"lower\") { #we are calculating a lower bound imputation\n    # \n    calculated_bound = map_dbl(.x = est, .f = calc_bounds, conf = conf, type = bound_type, scale = scale)\n    \n    imp_bound = if_else(is.na(lb), calculated_bound, lb)\n  }\n  \n  # if calculating upper bound variable\n  if(bound_type == \"upper\") { #we are calculating an upper bound imputation\n    # \n    calculated_bound = map_dbl(.x = est, .f = calc_bounds, conf = conf, type = bound_type, scale = scale)\n    imp_bound = if_else(is.na(ub), calculated_bound, ub)\n  }\n  \n  return(imp_bound)\n}\n\n# apply functions to evals_pub_long\n# where each row is one type of rating\n# so each evaluation is 9 rows long\nevals_pub_long <- evals_pub_long %>% \n  rowwise() %>% # apply function to each row\n  mutate(lb_imp_ = impute_bounds(var_name = rating_type,\n                                   est = est_,\n                                   lb = lb_, ub = ub_, conf = conf_,\n                                   bound_type = \"lower\")) %>% \n  mutate(ub_imp_ = impute_bounds(var_name = rating_type,\n                                   est = est_,\n                                   lb = lb_, ub = ub_, conf = conf_,\n                                   bound_type = \"upper\"))\n\n# Reshape evals_pub_long into evals_pub to add imputed bounds\nevals_pub <- evals_pub_long %>% \n  pivot_wider(names_from = rating_type, # take the dataframe back to old format\n              values_from = c(est_, ub_, lb_, conf_, lb_imp_, ub_imp_),\n              names_sep = \"\") %>% \n  dplyr::rename_with(.cols = matches(\"^[ul]b_imp\"),\n                     .fn = gsub,\n                     pattern = \"(ub_imp|lb_imp)_(.+)\", \n                     replacement = \"\\\\2_\\\\1\") %>% \n  dplyr::rename_with(.cols = starts_with(\"est_\"),\n                     .fn = gsub,\n                     pattern = \"est_(.+)\",\n                     replacement = \"\\\\1\")\n\n# Clean evals_pub_long names (remove _ at end)\nevals_pub_long <- evals_pub_long %>% \n  rename_with(.cols = ends_with(\"_\"),\n              .fn = str_remove,\n              pattern = \"_$\")\n```\n:::\n\n\n\nWe cannot publicly share the 'papers under consideration', but we can share some of the statistics on these papers. Let's generate an ID (or later, salted hash) for each such paper, and keep only the shareable features of interest\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"keep shareable variables from all papers\"}\nall_papers_p <- all_pub_records %>% \n  dplyr::select(\n    id,\n    category,\n    cfdc_DR,\n     'confidence -- user entered',\n    cfdc_assessor,\n    avg_cfdc,\n    category,\n    cause_cat_1_text,\n    cause_cat_2_text,\n    topic_subfield_text,\n    eval_manager_text,\n    'publication status',\n    'Contacted author?',\n    'stage of process/todo',\n    'source_main',  \n    'author permission?',\n'Direct Kotahi Prize Submission?',\n    'createdTime'         \n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Create and add aggregated ratings information to evals_pub_long\"}\n# paper_ratings: even longer dataframe (ie tidy)\n# renamed to conform to aggreCAT nomenclature\n\npaper_ratings <- evals_pub_long %>% \n  select(id, eval_name, paper_abbrev, rating_type, est, lb_imp, ub_imp) %>% \n  filter(rating_type %in% rating_cats) %>%\n  rename(paper_id = paper_abbrev,\n         user_name = eval_name,\n         three_point_lower = lb_imp,\n         three_point_upper = ub_imp,\n         three_point_best = est) %>%\n  mutate(round = \"round_1\") %>% \n  pivot_longer(cols = starts_with(\"three_point\"),\n               names_to = \"element\",\n               values_to = \"value\")\n\n# calculate aggregated upper and lower bounds using modified\n# aggreCAT function DistributionWAggMOD\npaper_agg_ratings <- paper_ratings %>% \n  group_by(rating_type, user_name, paper_id) %>% \n  filter(sum(is.na(value))==0) %>% #remove ratings (best, ub, lb) that have NA values\n  group_by(rating_type) %>% \n  nest() %>% \n  mutate(results = map(.x = data, .f = DistributionWAggMOD, \n                       round_2_filter = FALSE, percent_toggle = T)) %>% \n  unnest(results) %>% \n  select(-data) %>% \n  select(paper_id, rating_type, everything()) %>%   \n  arrange(paper_id) %>% \n  mutate(across(.cols = c(\"agg_est\", \"agg_90ci_lb\", \"agg_90ci_ub\"), .fns = ~.x*100)) %>% \n  rename(agg_method = method)\n\nrm(paper_ratings)\n\nevals_pub_long <- evals_pub_long %>% \n  left_join(paper_agg_ratings, by = c(\"paper_abbrev\" = \"paper_id\", \"rating_type\"=\"rating_type\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"create a dataset to be used as the input to the shiny app\"}\nevals_pub_long %>% \n  mutate(rating_type = factor(rating_type, \n                              levels = c(rating_cats, pred_cats),\n                              labels = c(\"Overall assessment\",\n                                         \"Advances our knowledge & practice\",  \n                                         \"Methods: justification, reasonableness, validity, robustness\", \n                                         \"Logic and communication\", \n                                         \"Engages with real-world, impact quantification\",\n                                         \"Relevance to global priorities\",\n                                         \"Open, collaborative, replicable science and methods\",\n                                         \"Predicted Journal\", \"Merits Journal\"))) %>% \n  write_rds(file = here(\"shinyapp/DataExplorer\", \"shiny_explorer.rds\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"save data for others' use\"}\nall_papers_p %>% saveRDS(file = here(\"data\", \"all_papers_p.Rdata\"))\nall_papers_p %>% write_csv(file = here(\"data\", \"all_papers_p.csv\"))\n\nevals_pub %>% saveRDS(file = here(\"data\", \"evals.Rdata\"))\nevals_pub %>% write_csv(file = here(\"data\", \"evals.csv\"))\n\nevals_pub_long %>% write_rds(file = here(\"data\", \"evals_long.rds\"))\nevals_pub_long %>% write_csv(file = here(\"data\", \"evals_long.csv\"))\n\n#evals_pub %>% readRDS(file = here(\"data\", \"evals.Rdata\"))\n```\n:::\n",
    "supporting": [
      "evaluation_data_input_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}